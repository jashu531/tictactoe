
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gamyday TicTacToe - Funky!</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Bangers&display=swap" rel="stylesheet">

  <!-- Socket.IO client library is crucial if you want the online mode to work -->
  <!-- This path assumes the Socket.IO server is serving the client library at /socket.io/socket.io.js -->
  <script src="/socket.io/socket.io.js"></script>

  <style>
    /* --- General Styles --- */
    body {
      background: linear-gradient(135deg, #f3ec78, #af4261); /* Funky gradient background */
      color: #333;
      font-family: 'Segoe UI', 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* Center content vertically by default */
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto; /* Allow scrolling if content exceeds viewport */
      animation: backgroundGradient 10s ease infinite alternate; /* Animated background */
    }

    @keyframes backgroundGradient {
        0% { background-position: 0% 50%; }
        100% { background-position: 100% 50%; }
    }

     /* Adjust body alignment when game is started */
     body.game-started {
         justify-content: flex-start; /* Align items to top when game is started */
         padding-top: 40px; /* Add some space at the top */
         padding-bottom: 40px; /* Add some space at the bottom */
     }


    /* --- Game Container --- */
    .game-container {
      background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent white background */
      padding: 30px; /* Increased padding */
      border-radius: 20px; /* More rounded corners */
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); /* Stronger shadow */
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 95%; /* Limit max width */
      width: auto; /* Adjust width based on content */
      position: relative; /* For potential positioning of elements */
      border: 5px solid #ff6f00; /* Adding a border */
    }

    /* --- Branding --- */
    .branding {
      font-size: 3em; /* Larger font size */
      font-weight: bold;
      color: #1db954; /* Keep green */
      margin-bottom: 20px;
      align-self: center; /* Center branding */
      font-family: 'Bangers', cursive;
      letter-spacing: 2px; /* More spacing */
      text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.1); /* Add subtle text shadow */
    }
    .branding span {
        color: #ff6f00; /* Keep orange */
        text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.1); /* Add subtle text shadow */
    }

    /* --- Status Message --- */
    .status-message {
      text-align: center;
      font-size: 1.6rem; /* Larger font size */
      color: #444;
      margin: 15px 0 20px 0; /* Adjusted margins */
      min-height: 1.8em; /* Ensure height */
      font-weight: bold;
      font-family: 'Permanent Marker', cursive;
      padding: 10px 20px; /* Add padding */
      border: 2px dashed #ff6f00; /* Dashed border */
      background-color: #fff9c4; /* Light yellow background */
      border-radius: 8px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
    }

    /* --- Game Controls & Buttons --- */
    .game-controls {
      margin-bottom: 25px; /* Increased margin */
      display: flex;
      flex-direction: column; /* Stack controls vertically */
      align-items: center;
      gap: 15px; /* Increased gap */
      width: 100%; /* Take full width for stacking */
    }

    .game-controls button, .restart-btn, .close-btn, .sound-toggle-btn {
      padding: 12px 25px; /* Increased padding */
      font-size: 1.1rem; /* Slightly larger font */
      background-color: #1db954; /* Green background */
      color: white;
      border: none;
      border-radius: 10px; /* More rounded corners */
      cursor: pointer;
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
      font-family: 'Bangers', cursive;
      letter-spacing: 1px; /* Increased spacing */
      text-transform: uppercase; /* Uppercase text */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add shadow */
      width: 100%; /* Make buttons take full width of controls container */
      max-width: 300px; /* Max width for buttons */
    }

    .game-controls button:hover, .restart-btn:hover, .close-btn:hover, .sound-toggle-btn:hover {
      background-color: #ff6f00; /* Orange on hover */
      transform: translateY(-3px) scale(1.05); /* Lift and slightly scale */
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* Stronger shadow on hover */
    }
    .game-controls button:active, .restart-btn:active, .close-btn:active, .sound-toggle-btn:active {
      transform: translateY(-1px) scale(1.02); /* Slightly lower and less scale on click */
      box-shadow: 0 3psx 6px rgba(0, 0, 0, 0.2);
    }
    .game-controls button:disabled, .sound-toggle-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      opacity: 0.7;
    }

    .close-btn {
        background-color: #e74c3c; /* Reddish close button */
    }
     .close-btn:hover {
         background-color: #c0392b; /* Darker red on hover */
         transform: translateY(-3px) scale(1.05);
     }
     .close-btn:active {
        transform: translateY(-1px) scale(1.02);
     }

     .sound-toggle-btn {
        background-color: #3498db; /* Blueish toggle button */
         margin-top: 10px; /* Add some space above it */
     }
      .sound-toggle-btn:hover {
          background-color: #2980b9; /* Darker blue */
      }


    /* Bot Difficulty Selection */
    .difficulty-selection {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        width: 100%;
        max-width: 300px; /* Match button max-width */
    }

    .difficulty-selection label {
        font-weight: bold;
        font-family: 'Bangers', cursive;
        font-size: 1.2rem;
        color: #333;
    }

    .difficulty-selection select {
        padding: 10px;
        font-size: 1rem;
        border-radius: 8px;
        border: 2px solid #1db954;
        font-family: 'Segoe UI', 'Arial', sans-serif;
        background-color: #fff;
        cursor: pointer;
        transition: border-color 0.3s ease;
        width: 100%; /* Match button width */
    }

    .difficulty-selection select:hover {
        border-color: #ff6f00;
    }


    /* --- Game Board (Responsive) --- */
    .board {
      display: grid;
      /* Use fractional units for flexible columns/rows, based on N=7 */
      grid-template-columns: repeat(7, 1fr);
      grid-template-rows: repeat(7, 1fr);
      /* Control the overall size of the board responsively using viewport units */
      /* Use min() to ensure it fits within the smaller dimension (width or height) and doesn't exceed a max size if needed */
      width: min(90vw, 90vh, 500px); /* Example: max 500px, but scale down */
      height: min(90vw, 90vh, 500px); /* Keep it square, scale down */
      gap: 1.5vmin; /* Gap scales with viewport size */
      background-color: #4a235a; /* Dark purple background for the board itself */
      padding: 3vmin; /* Padding scales with viewport size */
      border: 5px solid #f1c40f;
      border-radius: 15px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      /* Initially hidden, JS shows it */
      display: none;
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }

    /* --- Board Cells (Responsive & State-based Styling) --- */
    .cell {
      /* Remove fixed width/height - let the grid handle sizing (1fr makes them fill the grid area) */
      /* width: 55px; */
      /* height: 55px; */

      /* --- Default state: Empty, Not Clickable (e.g., during bot turn or game over) --- */
      background-color: #3498db; /* Vibrant blue background */
      color: #ffffff; /* Default white symbol color */
      font-size: 5vmin; /* Adjust as needed for symbol size, scales with viewport */
      font-weight: bold;
      font-family: 'Permanent Marker', cursive;
      line-height: 1;
      user-select: none;
      border-radius: 8px;
      transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.2); /* Inner shadow */
      pointer-events: none; /* Default state is not clickable */
      display: flex; /* Use flexbox to center content */
      justify-content: center;
      align-items: center;
    }

    /* --- Clickable state: Empty, Player's Turn --- */
    .cell.clickable {
        cursor: pointer;
        pointer-events: auto; /* Enable pointer events when clickable */
        /* Optional: Add specific styling for clickable empty cells if different from default blue */
        /* background-color: #5dade2; */ /* Lighter blue */
    }

    .cell.clickable:hover {
        /* Keep hover effect on clickable empty cells */
        background-color: #5dade2; /* Lighter blue on hover */
        transform: scale(1.05); /* Slight scale on hover */
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.5), inset 0 2px 5px rgba(0,0,0,0.2); /* Glow effect + inner shadow */
    }
     .cell.clickable:active {
         transform: scale(0.98); /* Slight press effect */
         box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
     }

    /* --- Taken state: After a move has been made --- */
    /* Applies when the cell gets the 'x' or 'o' class */
    .cell.taken {
      cursor: not-allowed;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.3); /* Stronger inner shadow when taken */
       pointer-events: none; /* Ensure taken cells are not clickable */
       /* The background and color are set by the .cell.x or .cell.o rules below */
    }

    /* Animation for placing X or O */
    .cell.x, .cell.o {
        animation: popIn 0.3s ease-out forwards; /* Pop in animation */
        text-shadow:
           -2px -2px 0 #eee,
            2px -2px 0 #eee,
            -2px 2px 0 #eee,
             2px 2px 0 #eee; /* Lighter text shadow around the symbol */
    }

    @keyframes popIn {
        0% { transform: scale(0.5); opacity: 0; }
        70% { transform: scale(1.1); opacity: 1; }
        100% { transform: scale(1); }
    }

    /* --- Player X Styling (Applies when cell has 'x' class) --- */
    .cell.x {
      color: #00008B; /* Dark blue symbol color for X */
      /* This overrides the default #ffffff color */
      background-color: #f1c40f; /* Yellow background color for X */
      /* This overrides the default #3498db background */
    }

    /* --- Player O Styling (Applies when cell has 'o' class) --- */
    .cell.o {
      color: #FFA500; /* Orange symbol color for O */
       /* This overrides the default #ffffff color */
      background-color: #e74c3c; /* Red background color for O */
       /* This overrides the default #3498db background */
    }

    /* --- Winning cell styles (Applies when cell gets 'winning' class) --- */
    /* These styles override the player colors and background with !important */
    .cell.winning {
      background-color: #2ecc71 !important; /* Vibrant green highlight */
      color: #fff !important; /* White text */
      text-shadow:
           -2px -2px 0 #333,
            2px -2px 0 #333,
            -2px 2px 0 #333,
             2px 2px 0 #333; /* Darker shadow for contrast */
      filter: none;
      animation: pulseWin 1s infinite alternate; /* Pulsing animation */
    }

    @keyframes pulseWin {
        0% { transform: scale(1); box-shadow: 0 0 10px #2ecc71; }
        100% { transform: scale(1.05); box-shadow: 0 0 20px #2ecc71; }
    }


    /* Styles for buttons shown after game over */
    .game-end-buttons {
        display: flex;
        gap: 15px; /* Increased gap */
        margin-top: 25px; /* Increased margin */
        justify-content: center;
        flex-wrap: wrap; /* Allow wrapping */
        /* Initially hidden, JS shows it */
        display: none;
    }

    .restart-btn, .close-btn {
      display: block;
      width: auto;
      min-width: 180px; /* Slightly wider buttons */
    }

     /* Hide audio elements visually */
    .sound-effects {
        display: none;
    }

  </style>
</head>
<body>
  <div class="game-container">
    <div class="branding">Gamyday <span>Funky Game!</span></div>
    <div class="status-message" id="statusMessage">Loading Game...</div>

    <!-- Player vs Player (Local) and Player vs Bot buttons -->
    <div class="game-controls" id="gameControls">
      <button onclick="startGameMode('player')">Player vs Player (Local)</button>

      <div class="difficulty-selection" id="botDifficultySelection">
           <label for="botDifficulty">Choose Bot Funky Level:</label>
           <select id="botDifficulty">
               <option value="easy">Easy Peasy</option>
               <option value="medium">Getting Funky</option>
               <option value="hard">Super Funky!</option>
           </select>
      </div>
      <button onclick="startGameMode('bot')">Play Funky Bot!</Button>

       <!-- Example Online Play Button - Requires Server/Lobby -->
       <!-- This button would typically redirect to a lobby page or trigger matchmaking -->
       <!-- <button onclick="window.location.href = '/lobby.html'">Play Online</button> -->
    </div>

    <!-- The board will be generated and managed by JavaScript -->
    <div class="board" id="board"></div>

    <div class="game-end-buttons" id="gameEndButtons">
        <!-- Text and click handler set by JS based on game mode -->
        <button class="restart-btn" id="restartButton">Restart Game!</button>
        <button class="close-btn" id="closeWindowButton">Exit Game</button>
    </div>

     <!-- Added Sound Toggle Button -->
     <button id="soundToggleButton" class="sound-toggle-btn">Turn Sound Off</button>


     <!-- Hidden audio elements for sound effects -->
     <div class="sound-effects">
         <!-- Using your specified file paths -->
         <audio id="moveSound" src="/sounds/playing.wav" preload="auto"></audio>
         <audio id="winSound" src="/sounds/win.wav" preload="auto"></audio>
         <audio id="lossSound" src="/sounds/lossing.wav" preload="auto"></audio>
         <!-- Draw sound removed as per your file list -->
     </div>

  </div>

  <script>
    console.log('Tic-Tac-Toe Script: Starting execution.');

    // Get references to HTML elements
    const boardElement = document.getElementById('board');
    const statusMessageElement = document.getElementById('statusMessage');
    const gameControlsElement = document.getElementById('gameControls');
    const restartButton = document.getElementById('restartButton');
    const closeWindowButton = document.getElementById('closeWindowButton');
    const gameEndButtonsContainer = document.getElementById('gameEndButtons');
    const botDifficultySelection = document.getElementById('botDifficultySelection'); // New element reference
    const botDifficultyDropdown = document.getElementById('botDifficulty'); // New element reference
    const soundToggleButton = document.getElementById('soundToggleButton'); // New element reference


     // Get references to audio elements
    const moveSound = document.getElementById('moveSound');
    const winSound = document.getElementById('winSound');
    const lossSound = document.getElementById('lossSound'); // Reference for the loss sound


    // Game Constants
    const N = 7; // Board size (7x7 grid)
    const WIN_LENGTH = 4; // Number of pieces in a row to win
    const PLAYER_X = 'X'; // Human player in bot mode, Player 1 in PvP
    const PLAYER_O = 'O'; // Bot player in bot mode, Player 2 in PvP
    // MINIMAX CONSTANTS (Adjust MAX_DEPTH for bot performance)
    const MAX_DEPTH = 3; // How many moves ahead the bot looks (higher = smarter, slower)
    const SCORES = { // Heuristic scores for board evaluation
        win: 1000,
        threeInARow: 50, // Potential for N-1 in a row
        twoInARow: 10,   // Potential for N-2 in a row
        centerPreference: 5, // Optional: prefer center cells
        lose: -1000, // Negative of win score
        draw: 0
    };


    // Matchmaking (Online) Game State
    // These variables are needed if you want the online mode to work
    let socket; // Socket.IO connection object
    let mm_roomId = null; // ID of the online game room
    let mm_mySymbol = null; // 'X' or 'O' for the local client in online game
    let mm_currentBoardState = Array(N * N).fill(null); // Server's board state (client keeps a copy)
    let mm_isMyTurn = false; // Boolean indicating if it's this client's turn online
    let mm_onlineGameOver = false; // Boolean indicating if the online game has ended
    let mm_winner = null; // Winner symbol ('X', 'O', or null) in online game
    let mm_isDraw = false; // Boolean indicating a draw in online game


    // Local Game State
    let local_cells = Array(N * N).fill(null); // Board state for local games
    let local_currentTurnSymbol = PLAYER_X; // 'X' or 'O' for the current turn in local game
    let local_gameOver = false; // Boolean indicating if the local game has ended
    let local_gameMode = ''; // '', 'player' (PvP), 'bot' (PvBot)
    let local_botDifficulty = 'easy'; // Default bot difficulty
    let winningCombination = null; // Array of indices for winning cells (used by both modes for highlighting)

    // Sound State
    // Load sound preference from localStorage, default to true
    let isSoundOn = localStorage.getItem('isSoundOn');
    if (isSoundOn === null) { // First time user visits
        isSoundOn = true;
        localStorage.setItem('isSoundOn', 'true');
    } else {
        isSoundOn = (isSoundOn === 'true'); // Convert string "true"/"false" to boolean
    }


    // --- Sound Functions ---
    // Added a check for readyState before attempting to play
    // Modified to check the global `isSoundOn` state
     function playSound(soundElement) {
         if (!isSoundOn || !soundElement) {
              // console.log("Sound playback skipped: isSoundOn=", isSoundOn, "element:", soundElement); // Optional debug
              return; // Exit if sound is off or element is null
         }
         // Check if the sound element is ready to play at least some data
         // HTMLMediaElement.HAVE_METADATA (1), HAVE_CURRENT_DATA (2), HAVE_FUTURE_DATA (3), HAVE_ENOUGH_DATA (4)
         if (soundElement.readyState >= 2) {
             soundElement.currentTime = 0; // Rewind to the start
             // Play returns a Promise, catch potential errors (like browser blocking)
             soundElement.play().catch(e => console.warn("Sound play failed:", e));
         } else {
              // console.warn("Sound element not ready or not element (state: " + (soundElement ? soundElement.readyState : 'N/A') + ")", soundElement); // Optional logging
              // Could potentially add an event listener here to play when ready, but complex for rapid sounds
         }
     }

     function playMoveSound() { playSound(moveSound); }
     function playWinSound() { playSound(winSound); }
     function playLossSound() { playSound(lossSound); }


     // Function to handle toggling sound
     function toggleSound() {
         console.log("Sound toggle clicked."); // Log click
         isSoundOn = !isSoundOn; // Toggle the state
         localStorage.setItem('isSoundOn', isSoundOn.toString()); // Save to localStorage
         console.log("Sound is now:", isSoundOn ? "On" : "Off"); // Log new state

         // Update button text
         if (soundToggleButton) {
             soundToggleButton.textContent = isSoundOn ? 'Turn Sound Off' : 'Turn Sound On';
         }

         // If sound is just turned ON, attempt a silent play unlock
         // This helps browsers allow audio playback triggered by non-direct user gestures later.
         // Only attempt if audio element exists and sound is now ON
          if (isSoundOn && moveSound) {
               console.log("Attempting silent play unlock after turning sound ON...");
               // Temporarily set volume very low
               moveSound.volume = 0.01;
              moveSound.play()
                  .then(() => {
                       // If successful, restore volume and maybe pause it instantly
                       console.log("Silent play unlock attempt successful.");
                       moveSound.volume = 1;
                       moveSound.pause(); // Pause immediately as it was just for unlocking
                       moveSound.currentTime = 0; // Rewind
                   })
                  .catch(e => console.warn("Silent play unlock attempt failed from mode button click (unexpected after click):", e));
          } else if (!isSoundOn) {
              // If sound is turned OFF, attempt to pause any currently playing sounds (though sounds are short)
              if (moveSound) moveSound.pause();
              if (winSound) winSound.pause();
              if (lossSound) lossSound.pause();
          }
     }


    // --- Initialize Game on DOM Ready ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOMContentLoaded fired. Initializing game.');

        // Check session storage for online game data
        mm_roomId = sessionStorage.getItem('roomId');
        mm_mySymbol = sessionStorage.getItem('mySymbol');
        // Retrieve gameMode and botDifficulty from session storage for continuity
        local_gameMode = sessionStorage.getItem('gameMode') || '';
        local_botDifficulty = sessionStorage.getItem('botDifficulty') || 'easy'; // Load saved difficulty
        console.log(`Initial state check: mm_roomId=${mm_roomId}, mm_mySymbol=${mm_mySymbol}, local_gameMode=${local_gameMode}, local_botDifficulty=${local_botDifficulty}`); // Log initial state from session


        // Set the dropdown value based on loaded difficulty (applies to mode selection state)
        if (botDifficultyDropdown) {
             botDifficultyDropdown.value = local_botDifficulty;
             // Add event listener to update local_botDifficulty when user changes dropdown value
              botDifficultyDropdown.addEventListener('change', (event) => {
                   local_botDifficulty = event.target.value;
                   sessionStorage.setItem('botDifficulty', local_botDifficulty); // Save change
                   console.log("Bot difficulty updated via dropdown:", local_botDifficulty);
                   // If in bot mode and it's X's turn, update status to show new level
                   if (local_gameMode === 'bot' && local_currentTurnSymbol === PLAYER_X && statusMessageElement) {
                       updateLocalGameStatus(); // Call update function to refresh status
                   }
              });
        }


         // Configure the sound toggle button text based on initial `isSoundOn` state
         // Add event listener
         if (soundToggleButton) {
             soundToggleButton.textContent = isSoundOn ? 'Turn Sound Off' : 'Turn Sound On';
             soundToggleButton.addEventListener('click', toggleSound);
         }

         // Configure Close Window Button - Handles both online exit (to lobby) and local exit (to menu)
         if (closeWindowButton) {
             closeWindowButton.onclick = handleExitGameClick; // Assign the shared handler
             closeWindowButton.style.display = 'block'; // Ensure visible by default
         }

         // Configure Restart Game Button - Handles both online (to lobby) and local (restart mode)
          if (restartButton) {
              // Text will be set dynamically by initializeMatchmakingGame or startGameMode
              restartButton.onclick = handleRestartGameClick; // Assign the shared handler
              // Initially hide, container display handles this
              // restartButton.style.display = 'none';
          }


         // Initially hide game end buttons container
         if(gameEndButtonsContainer) {
            gameEndButtonsContainer.style.display = 'none';
         }

         // --- Initial Setup Based on State ---
         const urlParams = new URLSearchParams(window.location.search);
         const modeParam = urlParams.get('mode'); // Check URL first for explicit mode
         console.log("URL mode parameter:", modeParam); // Log URL param

         // Determine initial state: Online game? Local game? Or mode selection?
         if (mm_roomId && mm_mySymbol) {
            // --- ONLINE GAME INIT (Resuming via Session Storage) ---
            console.log("Matchmaking game detected (via session). Initializing online game...");
            initializeMatchmakingGame(); // This function hides controls, sets online state, and shows the board later
            document.body.classList.add('game-started'); // Add class
            // Restart button text/action for online is handled in initializeMatchmakingGame
         } else if (modeParam || local_gameMode) {
             // --- LOCAL GAME START (via URL param or Session Storage) ---
             console.log(`Local game detected (via URL param "${modeParam || 'none'}" or session "${local_gameMode || 'none'}"). Starting game.`);
             const finalMode = modeParam || local_gameMode; // Use modeParam if present, otherwise session mode

             // Ensure bot difficulty is read if starting bot mode from session/param
             if (botDifficultyDropdown && finalMode === 'bot') {
                 local_botDifficulty = botDifficultyDropdown.value; // Get value from dropdown
                 sessionStorage.setItem('botDifficulty', local_botDifficulty); // Save difficulty to session storage
             } else {
                  // If not bot mode, clear bot difficulty from session just in case
                   sessionStorage.removeItem('botDifficulty');
                   local_botDifficulty = 'easy'; // Reset local var just in case
             }

            // If a mode is specified (local game), start it.
            startGameMode(finalMode); // This function handles resetting local state, setting UI, and starting game flow
            document.body.classList.add('game-started'); // Add class

            // Restart button text/action for local is handled in startGameMode
         } else {
             // --- SHOWING MODE SELECTION (Default state) ---
             console.log("No active game detected. Showing local game mode selection.");
             // This is the state where controls are shown, board is hidden or empty/unclickable.
             resetToModeSelection(); // Use the dedicated function to set this state
         }

         // --- Attempt to unlock audio on initial page load if a game is expected to start/resume ---
         // If a game is being resumed from session storage (mm_roomId or local_gameMode set),
         // there might not be an immediate user click to startGameMode.
         // Attempting a silent play here might help browsers allow later playback.
         // Only attempt if sound is supposed to be ON and audio element exists
         if (isSoundOn && (mm_roomId || local_gameMode) && moveSound) {
             console.log("Attempting initial audio unlock on page load...");
              // Note: This might still be blocked by the browser if no user interaction has occurred at all.
             moveSound.volume = 0.01; // Play at very low volume
              moveSound.play()
                  .then(() => { console.log("Initial audio unlock attempt successful."); moveSound.volume = 1; moveSound.pause(); moveSound.currentTime = 0; }) // Restore volume, pause, and rewind if successful
                  .catch(e => console.warn("Initial audio unlock attempt failed (this is common if triggered outside a user gesture):", e));
         }
    });

    // --- Shared Button Handlers ---

    // Handles the click on the "Restart Game" button
    function handleRestartGameClick() {
        console.log("Restart Game button clicked. Checking game mode..."); // Log the click

        // Check if currently in an online game mode (mm_roomId will be set)
        if (mm_roomId) {
            console.log("MM: Restart button clicked in online game. Navigating to lobby."); // Log online path
            // For online games, "Restart" means go back to the lobby (main page)
            // Clear session storage game state
            sessionStorage.removeItem('roomId');
            sessionStorage.removeItem('mySymbol');
            sessionStorage.removeItem('gameMode'); // Clear local mode too just in case
            sessionStorage.removeItem('botDifficulty'); // Clear bot difficulty
            sessionStorage.removeItem('serverId'); // Assuming serverId might also be stored

            // Disconnect socket if connected
            if(socket && socket.connected) {
                 socket.disconnect();
                 console.log("MM: Socket disconnected before navigation.");
            }

             // Navigate back to lobby (assuming '/' is your lobby page)
             window.location.href = '/';
        } else if (local_gameMode) {
             console.log(`Local: Restart button clicked in local game mode "${local_gameMode}". Restarting game.`); // Log local path
            // For local games, "Restart" means start a new game in the same mode
            // local_gameMode holds the current mode ('player' or 'bot')
            winningCombination = null; // Clear winning highlight before restarting
            startGameMode(local_gameMode); // Call the function to reset state and UI for a new game
        } else {
             console.warn("Restart button clicked, but no active game mode (local or online) detected. Resetting to selection."); // Log unexpected path
            // Fallback: If somehow clicked when in the selection state, just reset to selection
            resetToModeSelection();
        }
    }

    // Handles the click on the "Exit Game" button
    function handleExitGameClick() {
        console.log("Exit Game button clicked. Checking game mode..."); // Log the click

        // Disconnect socket if online game is active (regardless of where we navigate/close)
        if(mm_roomId && socket && socket.connected) {
             socket.disconnect();
             console.log("MM: Socket disconnected before exiting.");
        }

        // Clear relevant session storage for *any* game type on exit/return to menu/close
        sessionStorage.removeItem('roomId');
        sessionStorage.removeItem('mySymbol');
        sessionStorage.removeItem('gameMode');
        sessionStorage.removeItem('botDifficulty');
        sessionStorage.removeItem('serverId'); // Assuming serverId might also be stored
        console.log("Cleared session storage on Exit."); // Log clear

        // If in an online game, try to go back to the lobby/main page
        if (mm_roomId) {
             console.log("MM: Exit button clicked in online game. Navigating to lobby."); // Log online path
             window.location.href = '/'; // Go back to the main page/lobby
             // Attempt to focus opener if exists, then close (less reliable and often blocked)
             if (window.opener && !window.opener.closed) {
                 window.opener.focus();
                  // window.close(); // window.close is unreliable if not opened by script
             }
        } else {
            // If in a local game or on the selection screen, return to the selection screen
            console.log("Local: Exit button clicked. Resetting to mode selection."); // Log local path
            resetToModeSelection(); // Call the function that resets the UI and state to the selection screen
             // Note: window.close() is unreliable and removed here. The user must manually close the tab/window.
        }
    }


    // --- Matchmaking (Online) Game Functions ---
    // (These require a server-side Socket.IO application to work)

    function initializeMatchmakingGame() {
        console.log("MM: initializeMatchmakingGame called."); // Log function call
        console.log("MM: Attempting to initialize matchmaking game socket...");
        // Connect to the server
        // The io() function automatically tries to connect to the server that served the HTML file
        socket = io();

        socket.on('connect', () => {
            console.log('MM: Socket connected to server with ID:', socket.id);
            if (statusMessageElement) statusMessageElement.textContent = `Joining Game... You are Player ${mm_mySymbol}.`;
             // Hide local controls and difficulty selection
            if (gameControlsElement) gameControlsElement.style.display = 'none';
            if(botDifficultySelection) botDifficultySelection.style.display = 'none';

            // Set Restart button text for online mode
             if (restartButton) {
                  restartButton.textContent = 'Back to Lobby';
                  console.log("MM: Setting Restart button text to 'Back to Lobby'."); // Log change
             }


            // Send join message to server
            // Pass serverId if you are using it for multiple game servers (optional)
             const serverId = sessionStorage.getItem('serverId');
            socket.emit('joinGameRoom', { roomId: mm_roomId, mySymbol: mm_mySymbol, serverId: serverId });
             console.log(`MM: Emitted 'joinGameRoom' for room ${mm_roomId}, symbol ${mm_mySymbol}, serverId ${serverId}.`);
        });

        socket.on('gameState', (data) => {
            console.log('MM: Received gameState:', data);
            const previousBoardState = [...mm_currentBoardState]; // Store previous state for sound detection
            mm_currentBoardState = data.board; // Update board state from server
            mm_isMyTurn = (data.turn === mm_mySymbol); // Update turn status
            mm_onlineGameOver = data.gameOver; // Update game over status
            mm_winner = data.winner || null; // Update winner
            mm_isDraw = data.isDraw || false; // Update draw status
            winningCombination = data.winningCombination || null; // Update winning combination for highlighting

            // Show the board container once initial state is received
            if (boardElement && boardElement.style.display === 'none') {
                 console.log("MM: Showing board element on first gameState.");
                 boardElement.style.display = 'grid';
            }
             document.body.classList.add('game-started'); // Ensure body class is set


            renderBoard(mm_currentBoardState); // Re-render the board with the new state
            updateMatchmakingGameStatus(); // Update status message based on new state
            enableBoardClicking(); // Enable/disable clicks based on new state (turn/game over)

            // --- Play Sounds based on State Change ---
             if (mm_onlineGameOver) {
                 // Play win/loss sound only if a winner is declared (not on disconnect unless server sends winner)
                 if (mm_winner) {
                      if (mm_winner === mm_mySymbol) { // I won
                          playWinSound();
                      } else { // Opponent won
                          playLossSound();
                      }
                 }
                 // Draw sound removed as per requested files

             } else {
                 // Play move sound if the board state has changed and it's now the opponent's turn (or my turn after my move was processed)
                 // A simple way to detect a new move is if the number of non-null cells increased.
                 const previousFilled = previousBoardState.filter(cell => cell !== null).length;
                 const currentFilled = mm_currentBoardState.filter(cell => cell !== null).length;

                 if (currentFilled > previousFilled) {
                      playMoveSound();
                 }
             }


             // Show/hide end game buttons container based on online game state
             if (gameEndButtonsContainer) {
                  // Show if the game is explicitly marked as over by the server
                  gameEndButtonsContainer.style.display = mm_onlineGameOver ? 'flex' : 'none';
                  console.log("MM: gameState handler: Setting gameEndButtonsContainer display to", gameEndButtonsContainer.style.display);
             }
        });

        // 'moveMade' event - useful for immediate feedback, but 'gameState' is the source of truth
        socket.on('moveMade', (data) => {
            console.log('MM: Received moveMade (typically followed by gameState):', data);
             // Usually, you'd wait for the gameState update, but you could potentially
             // apply the move visually here optimistically before the full gameState arrives.
             // For now, we rely on gameState being sent immediately after.
        });

        socket.on('invalidMove', (data) => {
            console.warn('MM: Invalid move received from server:', data.message);
            if (statusMessageElement) {
                 const originalStatusText = statusMessageElement.textContent;
                 statusMessageElement.textContent = `Invalid Move: ${data.message}`;
                 // Briefly show the error, then revert status after a delay
                 setTimeout(() => {
                     // Only revert if the message hasn't changed again
                     if (statusMessageElement.textContent === `Invalid Move: ${data.message}`) {
                          updateMatchmakingGameStatus(); // Revert to actual game status
                     }
                  }, 3000); // Show error for 3 seconds
             }
             // Board state likely hasn't changed, re-enable clicks client-side if they were optimistically disabled
             enableBoardClicking(); // Ensure clicks are correct based on current state
        });

        socket.on('opponentDisconnected', (data) => {
             console.log('MM: Opponent disconnected event received:', data.message);
             // Only show this if the game wasn't already over by winning/draw
             if (!mm_onlineGameOver) {
                 mm_onlineGameOver = true; // Mark game as over on client side
                 mm_isMyTurn = false; // Ensure no more moves can be made

                 if (statusMessageElement) {
                    statusMessageElement.textContent = `Opponent disconnected: ${data.message || 'Game ended.'}`;
                 }
                 // Show end game buttons
                 if (gameEndButtonsContainer) {
                     gameEndButtonsContainer.style.display = 'flex';
                     console.log("MM: opponentDisconnected: Setting gameEndButtonsContainer display to flex.");
                 }
                 enableBoardClicking(); // Disable board clicks
                 // Note: Restart button is already 'Back to Lobby'
             }
        });

         socket.on('gameEnded', (data) => {
              console.log('MM: Game ended event received:', data);
              // This event confirms the final state (win/draw) and potentially the winner/combination
              mm_onlineGameOver = true;
              mm_winner = data.winner || null;
              mm_isDraw = data.isDraw || false;
              winningCombination = data.winningCombination || null;
              mm_isMyTurn = false; // Game is over

              // If this event includes the final board state, render it.
              // Otherwise, rely on the last 'gameState' or `moveMade` update.
              if (data.board) mm_currentBoardState = data.board;

              renderBoard(mm_currentBoardState); // Ensure final state is rendered
              updateMatchmakingGameStatus(); // Update status message
              enableBoardClicking(); // Disable board clicks

              // Play sounds based on final state if not already played by gameState handler
              // The gameState handler should be playing sounds based on the game being over,
              // but adding redundancy here is safe if gameState wasn't the *absolute* final state update.
              if (mm_winner) {
                  if (mm_winner === mm_mySymbol) {
                      playWinSound();
                  } else {
                      playLossSound();
                  }
              }
               // Draw sound removed

              // Show end game buttons
              if (gameEndButtonsContainer) {
                   gameEndButtonsContainer.style.display = 'flex';
                   console.log("MM: gameEnded: Setting gameEndButtonsContainer display to flex.");
              }
               // Restart button should already be 'Back to Lobby'
         });


        socket.on('serverError', (data) => {
            console.error('MM: Server Error in game:', data.message);
            // Display error and end game state on client
            if (statusMessageElement) statusMessageElement.textContent = `Error: ${data.message}. Please return to lobby.`;
            mm_onlineGameOver = true;
            mm_isMyTurn = false;
             // Show end game buttons
            if (gameEndButtonsContainer) {
                 gameEndButtonsContainer.style.display = 'flex';
                  console.log("MM: serverError: Setting gameEndButtonsContainer display to flex.");
            }
            enableBoardClicking(); // Disable board clicks
             // Restart button should already be 'Back to Lobby'
        });

        socket.on('disconnect', (reason) => {
            console.log('MM: Socket disconnected:', reason);
            // Only update status if game wasn't already explicitly ended by server event
            if (!mm_onlineGameOver && statusMessageElement) {
                statusMessageElement.textContent = `Disconnected (${reason}). Check connection or return to lobby.`;
            }
            // Ensure board is not clickable if disconnected
            mm_isMyTurn = false; // Assume not my turn if disconnected
            mm_onlineGameOver = true; // Mark game as over client-side on disconnect
            // Show end game buttons
            if (gameEndButtonsContainer) {
                 gameEndButtonsContainer.style.display = 'flex'; // Show end buttons on unexpected disconnect too
                 console.log("MM: disconnect: Setting gameEndButtonsContainer display to flex.");
            }
            enableBoardClicking(); // Disable board clicks
             // Restart button should already be 'Back to Lobby'
        });

        socket.on('connect_error', (err) => {
            console.error('MM: Connection Error:', err);
            // Display error and end game state on client
            if (statusMessageElement) statusMessageElement.textContent = 'Could not connect to game server. Please try again.';
            mm_onlineGameOver = true;
            mm_isMyTurn = false;
             // Show end game buttons
            if (gameEndButtonsContainer) {
                 gameEndButtonsContainer.style.display = 'flex';
                  console.log("MM: connect_error: Setting gameEndButtonsContainer display to flex.");
            }
            enableBoardClicking(); // Disable board clicks
             // Restart button should already be 'Back to Lobby'
        });
    }

    function updateMatchmakingGameStatus() {
        console.log("MM: Updating game status. Winner:", mm_winner, "Draw:", mm_isDraw, "Game Over:", mm_onlineGameOver, "My Turn:", mm_isMyTurn, "My Symbol:", mm_mySymbol);
        if (!statusMessageElement) {
            console.warn("MM: Status message element not found.");
            return;
        }

        // Check for win, draw, or other game over states first
        if (mm_winner) {
            statusMessageElement.textContent = mm_winner === mm_mySymbol ? `You (${mm_mySymbol}) WIN! Awesome Funky Win!` : `Player ${mm_winner} wins. Better luck next time!`;
        } else if (mm_isDraw) {
             statusMessageElement.textContent = "It's a Draw! Super Funky Tie!";
        } else if (mm_onlineGameOver) {
             // If game is over but no winner/draw (e.g., opponent disconnected, server error)
             // Keep the existing status message from those specific events if they set one.
             // If a specific message isn't set, use a generic one.
              if (!statusMessageElement.textContent.includes("Disconnected") &&
                  !statusMessageElement.textContent.includes("Error") &&
                   !statusMessageElement.textContent.includes("Game ended.")) {
                   statusMessageElement.textContent = "Game ended."; // Generic end message if no specific one set
              }
        } else if (mm_isMyTurn) {
            statusMessageElement.textContent = `Your turn (${mm_mySymbol})! Make a Funky Move!`;
        } else {
            // Game is active, not my turn
            const opponentSymbol = mm_mySymbol === PLAYER_X ? PLAYER_O : PLAYER_X; // Determine opponent symbol
             if (opponentSymbol) { // Ensure opponentSymbol is valid
                statusMessageElement.textContent = `Waiting for Opponent (${opponentSymbol})'s funky move...`;
             } else {
                 statusMessageElement.textContent = `Waiting for Opponent...`; // Fallback message
             }
        }
         console.log("MM: Status message set to:", statusMessageElement.textContent); // Log final status text

         // Control visibility of game end buttons container based on online game state
         if (gameEndButtonsContainer) {
             // Show if the game is explicitly marked as over by the server
            gameEndButtonsContainer.style.display = mm_onlineGameOver ? 'flex' : 'none';
             console.log("MM: updateMatchmakingGameStatus: Setting gameEndButtonsContainer display to", gameEndButtonsContainer.style.display);
         }
          // Set Restart button text for online mode (redundant here, but safe)
          if (restartButton && mm_onlineGameOver) { // Only set if game is actually over online
               restartButton.textContent = 'Back to Lobby';
               console.log("MM: Setting Restart button text to 'Back to Lobby' because game is over online.");
          }
    }

    // Handles UI click events *only* for online mode
    function handleOnlineCellClick(event) {
         // Get the index from the cell's data attribute
         const index = parseInt(event.target.dataset.index);
         if (isNaN(index)) {
              console.error("MM Click: Invalid cell index from data attribute:", event.target.dataset.index);
              return;
         }

         console.log(`MM Click: Clicked cell ${index}. My Turn: ${mm_isMyTurn}, Game Over: ${mm_onlineGameOver}, Cell Taken: ${mm_currentBoardState && mm_currentBoardState[index] !== null}`);

        if (mm_onlineGameOver) {
             console.log('Client check: MM Game over, ignoring move click.');
             // Briefly indicate game is over if they try clicking
             if (statusMessageElement) {
                  // Capture the current status before briefly showing the "Game is over!" message
                  const originalStatusText = statusMessageElement.textContent;
                  statusMessageElement.textContent = "Game is over!";
                  setTimeout(() => {
                       // Check if the status message is still the one we set before reverting
                       if (statusMessageElement.textContent === "Game is over!") {
                          updateMatchmakingGameStatus(); // Revert to the correct status based on game state
                       }
                  }, 1500);
             }
             return;
        }
        if (!mm_isMyTurn) {
            console.log('Client check: Not my turn, ignoring move click.');
             if (statusMessageElement) {
                  // Capture the current status before briefly showing "Not your turn!" message
                  const originalStatusText = statusMessageElement.textContent;
                  statusMessageElement.textContent = "Not your turn!";
                  setTimeout(() => {
                       // Check if the status message is still the one we set before reverting
                      if (statusMessageElement.textContent === "Not your turn!") {
                         updateMatchmakingGameStatus(); // Revert to actual game status
                      }
                   }, 1500);
             }
            return;
        }
         // Check if the cell is valid and empty according to the *current client state*
         // The server will do the final validation, but this provides immediate feedback.
         if (!mm_currentBoardState || mm_currentBoardState[index] !== null) {
             console.log('Client check: Cell is already taken or board state missing, ignoring move click.');
              if (statusMessageElement && mm_currentBoardState && mm_currentBoardState[index] !== null) {
                    // Capture the current status before briefly showing "Cell already taken!" message
                   const originalStatusText = statusMessageElement.textContent;
                    statusMessageElement.textContent = "Cell already taken!";
                    setTimeout(() => {
                        // Check if the status message is still the one we set before reverting
                        if (statusMessageElement.textContent === "Cell already taken!") {
                           updateMatchmakingGameStatus(); // Revert to actual game status
                        }
                   }, 1500);
              }
             return;
         }

        // If client-side checks pass, emit the move to the server
        if (socket && socket.connected) {
            socket.emit('makeMove', { roomId: mm_roomId, cellIndex: index });
            console.log(`MM: Emitted 'makeMove' for cell ${index} in room ${mm_roomId}.`);
            // Optimistically update status, waiting for server response
            if(statusMessageElement) statusMessageElement.textContent = "Move sent, waiting for server response...";
            // Optimistically disable clicks until server confirms with a new gameState
            enableBoardClicking(); // This will disable clicks because mm_isMyTurn will likely become false soon (server will switch turn)
        } else {
             console.error("MM: Socket not connected, cannot send move.");
             if(statusMessageElement) statusMessageElement.textContent = "Connection error. Cannot send move.";
             // If disconnected, should already be handled by disconnect/connect_error events setting game over
        }
    }


    // Controls which cells are clickable in online game mode
    function enableBoardClicking() {
        // This function is specifically for online games. Local games use enableLocalBoardClicking.
        // Check mm_roomId to ensure this logic only runs IN online mode
        if (!mm_roomId) {
             // console.log("MM: enableBoardClicking: Not in an online game, ignoring call."); // Suppress log
             // If not in an online game context, this function should do nothing.
             // Clickability for local/selection is handled by enableLocalBoardClicking.
             return;
        }
         console.log("MM: enableBoardClicking called (Online)."); // Log function call


         if (!boardElement || !mm_currentBoardState) {
             console.warn("MM: enableBoardClicking: Board element or board state missing.");
             return;
         }

        // In online mode, the board is clickable only if it's my turn AND the game is not over
        const canClickBoard = mm_isMyTurn && !mm_onlineGameOver;
        // console.log(`MM: enableBoardClicking: My Turn: ${mm_isMyTurn}, Game Over: ${mm_onlineGameOver}. Can Click Board: ${canClickBoard}`); // Suppress logging

        // Apply pointer-events to the entire board element container
        // This is the primary control for enabling/disabling clicks on the whole board
        boardElement.style.pointerEvents = canClickBoard ? 'auto' : 'none';
         console.log(`MM: Setting board pointer-events for clicks to ${canClickBoard ? 'auto' : 'none'}. State: MyTurn=${mm_isMyTurn}, GameOver=${mm_onlineGameOver}`); // Log clickability state


        // Add/remove 'clickable' class based on state and turn for visual feedback (hover effect)
        // The pointer-events on the board container handle the actual clickability,
        // but the class helps style available cells.
        const cells = boardElement.querySelectorAll('.cell');
        cells.forEach((cell, index) => {
              const isCellEmpty = mm_currentBoardState[index] === null;

              // A cell gets the 'clickable' class if the whole board is clickable for the player AND the cell is empty
              if (canClickBoard && isCellEmpty) {
                   // Add clickable class and ensure pointer events are enabled *on the cell* if the board is clickable
                   cell.classList.add('clickable');
                   cell.style.pointerEvents = 'auto';
              } else {
                  // Remove clickable class and ensure pointer events are disabled *on the cell*
                  cell.classList.remove('clickable');
                  cell.style.pointerEvents = 'none';
              }
        });
         console.log("MM: Updated cell clickable classes/pointer-events."); // Log cell updates
    }


    // --- Local Game Functions ---

    // Starts or restarts a local game
    function startGameMode(mode) {
        console.log(`Local: startGameMode called with mode: ${mode}`); // Log start of function

        // --- Clean up potential lingering state (online or old local) ---
        // Ensure online state is reset if starting a local game
        mm_roomId = null;
        mm_mySymbol = null;
        sessionStorage.removeItem('roomId');
        sessionStorage.removeItem('mySymbol');
        sessionStorage.removeItem('serverId');
        if(socket && socket.connected) {
             socket.disconnect();
             console.log("Local: Disconnected socket from previous online game (if any).");
        }
         // Reset online game state variables
         mm_currentBoardState = Array(N * N).fill(null);
         mm_isMyTurn = false;
         mm_onlineGameOver = false;
         mm_winner = null;
         mm_isDraw = false;
         // winningCombination is used by both, reset below


        // --- Set up local game state ---
        local_gameMode = mode;
        sessionStorage.setItem('gameMode', mode); // Save mode to session storage
        console.log(`Local: local_gameMode set to ${local_gameMode}`); // Log mode state

        // If starting bot mode, get difficulty from dropdown and save
         if (mode === 'bot' && botDifficultyDropdown) {
             local_botDifficulty = botDifficultyDropdown.value;
             sessionStorage.setItem('botDifficulty', local_botDifficulty);
             console.log(`Local Bot: Bot difficulty set to: ${local_botDifficulty}`);
         } else {
             // If not starting bot mode (or dropdown missing), clear difficulty from session
             sessionStorage.removeItem('botDifficulty');
             local_botDifficulty = 'easy'; // Reset local var just in case
         }

        local_cells = Array(N * N).fill(null); // Reset board state
        local_currentTurnSymbol = PLAYER_X; // X always starts local games
        local_gameOver = false;
        winningCombination = null; // Reset winning combination
        console.log("Local: Reset local game state variables."); // Log state reset


         // --- Attempt to unlock audio playback using the user's click on the mode button ---
         // This is the best place to try and "unlock" audio using a direct user gesture.
         // Only attempt if sound is supposed to be ON and audio element exists
         if (isSoundOn && moveSound) {
             console.log("Attempting audio unlock on mode button click...");
             // Play at a very low volume, or even volume=0 if the browser allows that to unlock
             moveSound.volume = 0.01;
             moveSound.play()
                 .then(() => { console.log("Audio unlock attempt successful from mode button click."); moveSound.volume = 1; moveSound.pause(); moveSound.currentTime = 0; }) // Restore volume, pause, and rewind if successful
                 .catch(e => console.warn("Audio unlock attempt failed from mode button click (unexpected after click):", e));
         }


        // --- Update UI for game start ---
        if (gameControlsElement) gameControlsElement.style.display = 'none';
        console.log("Local: Hiding game controls."); // Log UI change

        // Hide bot difficulty selection when game starts
        if(botDifficultySelection) botDifficultySelection.style.display = 'none';
        console.log("Local: Hiding bot difficulty selection."); // Log UI change


        if (boardElement) {
            boardElement.style.display = 'grid'; // SHOW the board
             console.log("Local: Showing board element."); // Log UI change
        } else {
             console.error("Board element not found when starting game mode!");
        }

        renderBoard(local_cells); // Render the fresh board
        console.log("Local: Called renderBoard."); // Log function call


        // Ensure game end buttons container is hidden at the start of a new game
         if (gameEndButtonsContainer) {
             gameEndButtonsContainer.style.display = 'none';
              console.log("Local: Hiding game end buttons container."); // Log UI change
         }
         // Ensure restart button text is correct for local game
         if (restartButton) {
              restartButton.textContent = 'Restart Game!';
              console.log("Local: Setting Restart button text to 'Restart Game!'."); // Log change
              // Event listener is set in DOMContentLoaded for local mode
         }


         document.body.classList.add('game-started'); // Indicate game is active
         console.log("Local: Added 'game-started' class to body."); // Log class change


        // Set initial status message using the helper function
        updateLocalGameStatus();
        console.log("Local: Called updateLocalGameStatus."); // Log function call


        // Update clickability based on initial state (X's turn, human)
        enableLocalBoardClicking(); // Enable clicks for the first human player (X)
        console.log("Local: Called enableLocalBoardClicking."); // Log function call

        // If starting a bot game and bot goes first (O), initiate bot move
        // In this game X always starts, so no bot move here at the very beginning.
    }


    // Core function to make a move in the local game state
    // This is called by handleLocalCellClick (human) or botMove (bot)
    function makeLocalMove(index, playerSymbol) {
        console.log(`makeLocalMove called for index ${index} by ${playerSymbol}`);

        // Basic validation (should already be checked before calling this, but safety first)
        if (local_gameOver) {
             console.warn(`makeLocalMove: Game is over, cannot make move at ${index}.`);
             return; // Do nothing if game is already over
        }
        if (local_cells[index] !== null) {
            console.warn(`makeLocalMove: Cell ${index} is already taken (${local_cells[index]}).`);
            enableLocalBoardClicking(); // Re-evaluate clickability just in case
            return;
        }
        // Ensure the player attempting the move is the current player
         if (local_currentTurnSymbol !== playerSymbol) {
             console.warn(`makeLocalMove: Attempted move by wrong player. Expected ${local_currentTurnSymbol}, got ${playerSymbol}.`);
              enableLocalBoardClicking(); // Re-evaluate clickability
             return;
         }


        // Apply the move to the local state array
        local_cells[index] = playerSymbol;
        console.log("Local state after move:", [...local_cells]); // Log a copy


        // Update the single cell element visually immediately
        const cellElement = boardElement.children[index];
        if (cellElement) {
            cellElement.textContent = playerSymbol;
            cellElement.classList.add(playerSymbol.toLowerCase());
            cellElement.classList.add('taken'); // Mark as taken
             cellElement.classList.remove('clickable'); // Remove clickable style
            cellElement.style.pointerEvents = 'none'; // Ensure element pointer events are off
             playMoveSound(); // Play move sound after successful placement
             console.log(`Local: Updated cell ${index} visually.`); // Log visual update
        } else {
            console.error("Cell element not found for index", index, "during makeLocalMove.");
        }


        // Check for win or draw AFTER the move has been applied
        winningCombination = null; // Reset before checking
        const winnerInfo = checkForWinner(playerSymbol, local_cells);
        console.log(`Local: checkForWinner result:`, winnerInfo); // Log winner check result


        if (winnerInfo) {
            // Game over - Winner
            local_gameOver = true;
            winningCombination = winnerInfo.combination;
            highlightWinningCells(winningCombination); // Highlight winning cells
            console.log(`Local: Game Over - Winner: ${winnerInfo.player}`); // Log game end type

             // Play win or loss sound based on who won relative to the human player (X)
             if (winnerInfo.player === PLAYER_X) { // Human (X) won
                 playWinSound();
             } else if (winnerInfo.player === PLAYER_O) { // Bot (O) won
                 playLossSound();
             }


        } else if (!local_cells.includes(null)) {
            // Game over - Draw (No winner and no empty cells)
            local_gameOver = true;
            console.log("Local: Game Over - Draw."); // Log game end type
            // Draw sound removed as per requested files

        }

        // Update status message and switch turn ONLY if game is NOT over
        updateLocalGameStatus(); // Update status message based on new state
        console.log("Local: Called updateLocalGameStatus after move."); // Log function call


        if (local_gameOver) {
             local_currentTurnSymbol = ''; // No one's turn anymore
             console.log("Local: local_gameOver is true. Setting currentTurnSymbol to ''."); // Log state change

             // Show the game end buttons container
             if (gameEndButtonsContainer) {
                 gameEndButtonsContainer.style.display = 'flex';
                  console.log("Local: makeLocalMove: Game over, showing gameEndButtonsContainer."); // Log UI change
             }
             // Restart button text is already "Restart Game!" for local mode

             // Clickability will be disabled by enableLocalBoardClicking below because local_gameOver is true
        } else {
            // Game is not over, switch turns
            local_currentTurnSymbol = playerSymbol === PLAYER_X ? PLAYER_O : PLAYER_X;
             console.log(`Local: Game not over. Switching turn to ${local_currentTurnSymbol}.`); // Log state change

            // If it's the bot's turn (and game is not over), initiate bot move
            if (local_gameMode === 'bot' && local_currentTurnSymbol === PLAYER_O) {
                 console.log("Local: It's bot's turn, initiating botMove."); // Log bot turn
                 // Bot's turn - status message is already set to "thinking..." by updateLocalGameStatus
                 // enableLocalBoardClicking() called below will disable human clicks
                 // Call botMove with a slight delay
                 setTimeout(botMove, 500); // Delay bot move slightly
            }
        }

         // Always re-evaluate clickability after a move, based on the NEW state (turn, game over)
         // This enables clicks for the next human player or disables them for the bot/game over
         enableLocalBoardClicking();
         console.log("Local: Called enableLocalBoardClicking after move."); // Log function call
    }


    // Handles UI click events *only* for local mode (human player)
    // Note: This handler is attached to each cell during renderBoard.
    function handleLocalCellClick(event) {
         // Get the index from the cell's data attribute
         const index = parseInt(event.target.dataset.index);
         if (isNaN(index)) {
             console.error("Local Click: Invalid cell index from data attribute:", event.target.dataset.index);
             return;
         }
         console.log(`Local Click: Cell ${index} clicked.`); // Log click event

         // Primary checks: is game over? is cell taken?
         if (local_gameOver || local_cells[index] !== null) {
              console.log("Local Click: Game over or cell taken, ignoring click.");
               if (statusMessageElement && local_cells[index] !== null) { // Only show message if cell is taken
                   // Capture the current status before briefly showing "Cell already taken!" message
                   const originalStatusText = statusMessageElement.textContent;
                    statusMessageElement.textContent = "Cell already taken!";
                    setTimeout(() => {
                        // Check if the status message is still the one we set before reverting
                        if (statusMessageElement.textContent === "Cell already taken!") {
                           updateLocalGameStatus(); // Revert to actual game status
                        }
                   }, 1500);
               } else if (local_gameOver && statusMessageElement) {
                    // If game is over, clicking taken cells should just re-assert game over status message
                    updateLocalGameStatus();
               }
              return; // Click should ideally not be possible due to pointer-events/clickable class, but check is safe
         }

         // Additional check for bot mode: ensure it's the human player's (X's) turn
         if (local_gameMode === 'bot' && local_currentTurnSymbol === PLAYER_O) {
              console.log("Local Click: It's bot's turn, human click ignored.");
              if (statusMessageElement) {
                   // Briefly show a message without overwriting the thinking status permanently
                   const originalStatusText = statusMessageElement.textContent; // Store bot thinking status
                   // Avoid stacking messages if bot thinking status or "Waiting for the bot!" is already set
                   if (!originalStatusText.includes("thinking") && !originalStatusText.includes("Waiting")) {
                       statusMessageElement.textContent = "Waiting for the bot!";
                       setTimeout(() => {
                           // Revert to original message if it hasn't changed
                           if(statusMessageElement.textContent === "Waiting for the bot!") {
                              updateLocalGameStatus(); // Revert to the correct status (likely "thinking...")
                           }
                      }, 1500);
                   }
              }
              return; // Do not proceed if it's the bot's turn
         }

        // If all checks pass, it's a valid human move in local mode
        console.log(`Local Click: Valid human move at index ${index} for player ${local_currentTurnSymbol}. Making move.`);
        makeLocalMove(index, local_currentTurnSymbol); // Call the core logic to apply the move
    }

    // Helper to update local game status message based on current state
    function updateLocalGameStatus() {
         console.log("updateLocalGameStatus called."); // Log function call
         if (!statusMessageElement) return;

         if (local_gameOver) {
             if (winningCombination) {
                  // Get winner symbol from a winning cell, assuming winningCombination is set
                  // Defensive check: ensure winningCombination is valid before using it
                  const winner = (winningCombination && Array.isArray(winningCombination) && winningCombination.length > 0) ? local_cells[winningCombination[0]] : null;
                  if (winner) {
                      statusMessageElement.textContent = `${winner} is the WINNER! Awesome Funky Win!`;
                  } else {
                       console.warn("Game over with winningCombination but could not determine winner symbol.");
                       statusMessageElement.textContent = "Game Over!"; // Fallback status
                  }
             } else if (!local_cells.includes(null)) { // Check if board is full for draw
                 statusMessageElement.textContent = "It's a DRAW! Super Funky Tie!";
             } else {
                  // Should not happen if game over is true but no winner or draw
                  console.warn("Game over state reached without winner or full board?");
                   statusMessageElement.textContent = "Game Over!"; // Fallback status
             }
         } else { // Game is not over
              if (local_gameMode === 'player') {
                  statusMessageElement.textContent = `${local_currentTurnSymbol}'s turn! Go for it!`;
              } else if (local_gameMode === 'bot') {
                   if (local_currentTurnSymbol === PLAYER_X) {
                       statusMessageElement.textContent = `${local_currentTurnSymbol}'s turn! Make your Funky Move! (Level: ${local_botDifficulty})`;
                   } else { // Bot's turn (O)
                        statusMessageElement.textContent = `Funky Bot (O) is thinking... (Level: ${local_botDifficulty})`;
                   }
              } else { // Game is in mode selection state ('')
                   statusMessageElement.textContent = "Select a mode to start your funky game!";
              }
         }
         console.log("Status message set to:", statusMessageElement.textContent); // Log final status text
    }


    // Controls which cells are clickable in local game modes and selection screen
    // This function is for local games and the initial selection state.
    // Online mode uses enableBoardClicking.
    function enableLocalBoardClicking() {
         // Check mm_roomId to ensure this logic only runs OUTSIDE of online mode
        if (mm_roomId) {
             // console.log("enableLocalBoardClicking: In online mode, ignoring call."); // Suppress log
             return;
        }
         console.log("enableLocalBoardClicking called (Local/Selection)."); // Log function call


         if (!boardElement) {
             console.warn("enableLocalBoardClicking: Board element not found.");
             return;
         }

        // Determine if human clicks should be allowed on the board container level
        // Clicks are allowed on the board container only if:
        // 1. A local game mode is currently active (`local_gameMode !== ''`)
        // AND
        // 2. Game is NOT over (`!local_gameOver`)
        // AND
        // 3. (It's PlayerVsPlayer mode) OR (It's Bot mode AND it's the human player's (X's) turn)
         const canHumanClickOnBoardContainer = local_gameMode !== '' && !local_gameOver && (local_gameMode === 'player' || (local_gameMode === 'bot' && local_currentTurnSymbol === PLAYER_X));

         boardElement.style.pointerEvents = canHumanClickOnBoardContainer ? 'auto' : 'none';
          console.log(`Local: Setting board pointer-events for human clicks to ${canHumanClickOnBoardContainer ? 'auto' : 'none'}. State: Mode=${local_gameMode || 'none'}, Turn=${local_currentTurnSymbol || 'none'}, GameOver=${local_gameOver}`); // Log clickability state


         // Update the 'clickable' class on individual cells for visual feedback (hover effect)
         // This class is only applied if the *board container* is clickable *and* the cell is empty.
         // This ensures cells aren't styled as clickable if the whole board is disabled (e.g., bot turn, game over, selection screen).
         const cells = boardElement.querySelectorAll('.cell');
          cells.forEach((cell, index) => {
               const isCellEmpty = local_cells[index] === null;

               // A cell gets the 'clickable' class if the board container is enabled for human clicks AND the cell is currently empty
               if (canHumanClickOnBoardContainer && isCellEmpty) {
                   cell.classList.add('clickable');
                   cell.style.pointerEvents = 'auto'; // Ensure individual cell allows clicks if container does
               } else {
                   cell.classList.remove('clickable');
                   cell.style.pointerEvents = 'none'; // Ensure individual cell blocks clicks if taken or board disabled
               }
         });
         console.log("Local: Updated cell clickable classes/pointer-events."); // Log cell updates
    }


    // --- Bot Logic ---

    function botMove() {
         console.log(`Local Bot: BotMove function called. Difficulty: ${local_botDifficulty}`);
         // Ensure it's local bot mode, game is not over, and it's O's turn
         // Check mm_roomId to ensure this only runs in local mode
         if (mm_roomId || local_gameOver || local_gameMode !== 'bot' || local_currentTurnSymbol !== PLAYER_O) {
              console.log("Local Bot: Conditions not met for bot move. Exiting.", { mm_roomId, local_gameOver, local_gameMode, local_currentTurnSymbol });
              // If somehow called in wrong state, ensure clickability is correct based on current (wrong) state
              enableLocalBoardClicking();
              return;
         }

         console.log(`Local Bot: Finding move for level: ${local_botDifficulty}...`); // Log bot thinking step
         // Human clicks were disabled by enableLocalBoardClicking when O's turn started

         let moveIndex = -1; // Default invalid move

         const availableCells = getAvailableCells(local_cells);

         if (availableCells.length === 0) {
             console.log("Local Bot: No available cells left.");
              // This case should lead to a draw, handled by makeLocalMove check.
              enableLocalBoardClicking(); // Ensure human clicks are off
              return;
         }

         switch (local_botDifficulty) {
             case 'easy':
                 console.log("Local Bot: Easy mode - Picking random move.");
                 moveIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
                 break;

             case 'medium':
                 console.log("Local Bot: Medium mode - Checking for winning/blocking moves.");
                 moveIndex = findMediumMove(local_cells, PLAYER_O, PLAYER_X);
                 if (moveIndex === -1) { // If no winning or blocking move found
                     console.log("Local Bot (Medium): No immediate win/block. Picking random move.");
                     moveIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
                 }
                 break;

             case 'hard':
                 console.log("Local Bot: Hard mode - Using Minimax.");
                 // Minimax looks ahead from the bot's perspective (maximizing its score)
                 // Need to provide the current state, depth 0, maximizing player (Bot=O), minimizing player (Human=X)
                 const bestMove = findBestMoveMinimax(local_cells, 0, true, -Infinity, Infinity, PLAYER_O, PLAYER_X);
                 moveIndex = bestMove.index;
                 console.log("Local Bot (Hard): Minimax selected move index:", moveIndex, "with score:", bestMove.score);

                 // Handle case where Minimax didn't find a move (e.g., board full or weird state)
                 if (moveIndex === -1 && availableCells.length > 0) {
                     console.warn("Minimax failed to return a move, picking random available cell as fallback.");
                     moveIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
                 }
                 break;

             default:
                 console.warn(`Local Bot: Unknown difficulty '${local_botDifficulty}'. Falling back to easy.`);
                 moveIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
         }

         // After determining the move, perform validation again before making it
          // Check if game is NOT over, the target cell is still empty, AND it's still O's turn
         if (moveIndex !== -1 && local_cells[moveIndex] === null && local_currentTurnSymbol === PLAYER_O && !local_gameOver) {
             console.log("Local Bot: Making move at index", moveIndex); // Log move
             // The makeLocalMove function handles updating UI, switching turn, checking for end game, and calling enableLocalBoardClicking
             makeLocalMove(moveIndex, PLAYER_O);
         } else {
              console.warn("Local Bot: Determined move index is invalid or state changed. Cannot make move.", { moveIndex, local_gameOver, cellValue: local_cells[moveIndex], currentTurn: local_currentTurnSymbol });
              // If state is invalid (e.g., human clicked before bot finished thinking), just ensure clickability is correct
              enableLocalBoardClicking(); // Re-evaluate clickability based on potentially new state
         }
    }

    // Medium Bot Logic: 1-ply lookahead (check immediate win or block)
    function findMediumMove(board, mySymbol, opponentSymbol) {
        const availableCells = getAvailableCells(board);

        // 1. Check if bot can win in the next move
        for (const index of availableCells) {
            const testBoard = [...board]; // Create a copy to simulate
            testBoard[index] = mySymbol;
            if (checkForWinner(mySymbol, testBoard)) {
                console.log(`Local Bot (Medium): Found winning move at ${index}`);
                return index; // Take the winning move!
            }
        }

        // 2. Check if opponent can win in their next move and block it
        for (const index of availableCells) {
            const testBoard = [...board]; // Create a copy to simulate
            testBoard[index] = opponentSymbol;
            if (checkForWinner(opponentSymbol, testBoard)) {
                console.log(`Local Bot (Medium): Found opponent winning move at ${index}. Blocking.`);
                return index; // Block the opponent's winning move!
            }
        }

        // 3. No immediate win or block found, return -1
        return -1; // No special move found
    }

    // --- Hard Bot Logic: Minimax ---

    // Finds the best move using the minimax algorithm
    // Returns { index: bestMoveIndex, score: bestScore } only when depth 0
    // Returns score otherwise
    function findBestMoveMinimax(board, depth, isMaximizingPlayer, alpha, beta, mySymbol, opponentSymbol) {
         // Note: This function is the starting point for the Minimax *algorithm*.
         // The actual recursive function is `minimax`.
         // This function finds the best move *index* at the root (depth 0).

         const availableCells = getAvailableCells(board);
         let bestScore = isMaximizingPlayer ? -Infinity : Infinity; // Max player wants highest score, Min player wants lowest
         let bestMoveIndex = -1; // Only used at depth 0

         // console.log("Local Bot (Hard/Minimax): Starting root search..."); // Avoid spamming console

         // Base Case: Check for terminal states or max depth
         // Check for win for the player *who just made the move* (the player opposite of the current isMaximizingPlayer state).
         const playerWhoJustMoved = isMaximizingPlayer ? opponentSymbol : mySymbol;
         const winnerInfo = checkForWinner(playerWhoJustMoved, board);

         if (winnerInfo) {
             // Terminal state found (win/loss)
             if (winnerInfo.player === mySymbol) { // If *mySymbol* won (bot's symbol)
                  // Bot wins. Positive score. Adjust by depth to prefer faster wins.
                  // The score is from the perspective of the MaximizingPlayer (bot).
                  return SCORES.win - depth; // Favor wins closer to the current move
             } else if (winnerInfo.player === opponentSymbol) { // If *opponentSymbol* won (human's symbol)
                  // Bot loses. Negative score. Adjust by depth to penalize deeper losses less.
                  // If the state is a win for the opponent:
                  return SCORES.lose + depth; // Penalize losses further away less
             }
              // Should not reach here if winnerInfo is not null and player matches
        }


        if (!availableCells.length) {
            return SCORES.draw; // Draw (board is full)
        }

        if (depth >= MAX_DEPTH) {
            // Reached max depth, evaluate the current board heuristically
            // Evaluate from the perspective of the player *whose turn it is* next (isMaximizingPlayer)
            // The score is always returned from the bot's (mySymbol's) perspective.
            // console.log(`Minimax: Reached max depth ${depth}. Evaluating.`); // Log depth limit
            return evaluateBoard(board, mySymbol, opponentSymbol); // Evaluate from bot's perspective (mySymbol)
        }

        // Recursive Step
        // Get moves relevant to the current player (Maximizing=bot, Minimizing=opponent)
        const currentPlayerSymbol = isMaximizingPlayer ? mySymbol : opponentSymbol;
        const nextIsMaximizing = !isMaximizingPlayer; // Next turn switches player type


        if (isMaximizingPlayer) { // Bot's turn (Maximizing player)
            let maxEval = -Infinity;
            // Iterate through available moves
             // Shuffle available cells at the root depth for variety, otherwise process normally
            const cellsToEvaluate = depth === 0 ? shuffleArray([...availableCells]) : availableCells;

            for (const index of cellsToEvaluate) {
                const newBoard = [...board];
                newBoard[index] = currentPlayerSymbol; // Simulate current player's move

                // Call minimax for the opponent's turn (minimizing player)
                const evaluation = minimax(newBoard, depth + 1, nextIsMaximizing, alpha, beta, mySymbol, opponentSymbol);

                // console.log(`Minimax: Depth ${depth}, Move ${index} evaluation: ${evaluation}`); // Avoid spamming console

                if (evaluation > maxEval) {
                    maxEval = evaluation;
                    if (depth === 0) { // Only record the move index at the root level (depth 0)
                        bestMoveIndex = index;
                    }
                }
                alpha = Math.max(alpha, evaluation); // Update alpha
                if (beta <= alpha) {
                     // console.log("Minimax: Alpha-beta pruning branch cut (Maximizing)."); // Suppress logging
                    break; // Alpha-beta pruning
                }
            }
             // At the root (depth 0), return the move index and score.
             // In recursive calls (depth > 0), just return the score.
            return depth === 0 ? { index: bestMoveIndex, score: maxEval } : maxEval;

        } else { // Opponent's turn (Minimizing player)
            let minEval = Infinity;
             // Iterate through available moves for the current player
            for (const index of availableCells) {
                const newBoard = [...board];
                newBoard[index] = currentPlayerSymbol; // Simulate current player's move

                // Call minimax for the bot's turn (maximizing player)
                const evaluation = minimax(newBoard, depth + 1, nextIsMaximizing, alpha, beta, mySymbol, opponentSymbol);
                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, evaluation); // Update beta
                if (beta <= alpha) {
                    // console.log("Minimax: Alpha-beta pruning branch cut (Minimizing)."); // Suppress logging
                    break; // Alpha-beta pruning
                }
            }
            return minEval;
        }
    }


     // Fisher-Yates (aka Knuth) Shuffle - Helper for Minimax root moves
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]]; // Swap elements
        }
        return array; // Return the shuffled array
    }


    // Heuristic evaluation function for the board state
    // Gives a score from the perspective of the bot (mySymbol)
    function evaluateBoard(board, mySymbol, opponentSymbol) {
        let score = 0;

        // Helper function to count potential patterns (like N-1, N-2 in a row with empty spaces)
        function countPotentialLines(board, player) {
            let playerScore = 0;
            const playerTarget = player;
            const opponentTarget = player === mySymbol ? opponentSymbol : mySymbol;

            const directions = [
                { dr: 0, dc: 1 }, // Horizontal
                { dr: 1, dc: 0 }, // Vertical
                { dr: 1, dc: 1 }, // Diagonal /
                { dr: 1, dc: -1 } // Diagonal \
            ];

            // Iterate through all possible starting cells for a WIN_LENGTH line
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {

                     // Check each direction from this cell
                     for (const direction of directions) {
                          let playerCount = 0;
                          let emptyCount = 0;
                          let blocked = false; // Is this potential line blocked by the opponent?

                          // Check WIN_LENGTH cells in this direction
                          for (let k = 0; k < WIN_LENGTH; k++) {
                              const currRow = r + k * direction.dr;
                              const currCol = c + k * direction.dc;
                              const currIndex = currRow * N + currCol;

                               // Check bounds
                              if (currRow >= 0 && currRow < N && currCol >= 0 && currCol < N) {
                                   const cellValue = board[currIndex];

                                   if (cellValue === playerTarget) {
                                       playerCount++;
                                   } else if (cellValue === null) {
                                       emptyCount++;
                                   } else {
                                        // Opponent piece blocks this potential line
                                        blocked = true;
                                        break; // Stop checking this specific line segment
                                   }
                              } else {
                                  // Out of bounds, invalid line segment
                                  blocked = true; // Consider out of bounds as blocked
                                  break; // Stop checking this specific line segment
                              }
                          }

                          // If the line segment isn't blocked and could potentially be completed (contains only player pieces and empty cells)
                           if (!blocked && (playerCount + emptyCount) === WIN_LENGTH) {
                               // Assign scores based on the number of player pieces in the potential line
                               // Prioritize lines with more pieces for the current player (bot)
                               // Weaker lines get lower scores.
                               // Note: Exact win (playerCount === WIN_LENGTH) is handled by the base case in minimax.
                               if (playerCount === WIN_LENGTH - 1) { // e.g., 3 in a row for WIN_LENGTH=4
                                   playerScore += SCORES.threeInARow;
                               } else if (playerCount === WIN_LENGTH - 2) { // e.g., 2 in a row
                                   playerScore += SCORES.twoInARow;
                               }
                                // You could add more cases like playerCount === WIN_LENGTH-3 etc.
                           }
                     }
                }
            }
             return playerScore;
        }

        // Calculate potential scores for bot (maximizing) and opponent (minimizing)
        const botPotentialScore = countPotentialLines(board, mySymbol);
        const opponentPotentialScore = countPotentialLines(board, opponentSymbol);

        // The heuristic score is the difference between bot's potential and opponent's potential
        score = botPotentialScore - opponentPotentialScore;

         // Add a preference for center columns (optional heuristic)
         const centerCol = Math.floor(N / 2);
         for (let r = 0; r < N; r++) {
              const index = r * N + centerCol;
              if (board[index] === mySymbol) {
                  score += SCORES.centerPreference;
              } else if (board[index] === opponentSymbol) {
                  score -= SCORES.centerPreference;
              }
         }

        // console.log("Minimax Evaluation Score:", score); // Suppress logging
        return score;
    }


    // Initiates a restart for the local game mode or resets to selection
    // NOTE: This function is called internally for local game restarts (e.g., after a move).
    // The "Restart Game" BUTTON click handler is `handleRestartGameClick`.
    function requestRestartGame() {
         console.log("requestRestartGame called (Internal Local Restart)."); // Log function call

        // Logic for restarting local game mode
        if (local_gameMode) {
            console.log(`Local: Restarting mode: ${local_gameMode} via internal request.`); // Log which mode is restarting
            // Clear winning combination and re-call startGameMode with the current mode
            winningCombination = null; // Clear highlight
            startGameMode(local_gameMode); // This will reset state and UI
        } else {
             console.warn("Internal requestRestartGame called with no active local game mode. Resetting to selection."); // Log unexpected state
             // Fallback: If somehow called when in the selection state, just reset to selection
             resetToModeSelection();
        }
    }


     // Central function to reset the UI and state to the mode selection screen
     // Used on initial load if no game is active, or when exiting a local game via a "Back to Menu" button or fallback restart.
     function resetToModeSelection() {
          console.log("resetToModeSelection called."); // Log function call

          // --- Clean up ALL game state (local and online) ---
          local_cells.fill(null);
          local_gameOver = false;
          local_currentTurnSymbol = PLAYER_X; // Reset turn symbol (though not used in this state)
          winningCombination = null; // Clear winning highlight
          local_gameMode = ''; // Explicitly set mode to none for selection screen
          console.log("Reset: Local game state variables cleared."); // Log state reset

          // Clear local game session storage
          sessionStorage.removeItem('gameMode');
          sessionStorage.removeItem('botDifficulty');
          console.log("Reset: Cleared local game session storage."); // Log session storage clear

          // Also clear online game state and session storage (belt and suspenders)
          mm_roomId = null;
          mm_mySymbol = null;
          mm_currentBoardState.fill(null);
          mm_isMyTurn = false;
          mm_onlineGameOver = false;
          mm_winner = null;
          mm_isDraw = false;
          sessionStorage.removeItem('roomId');
          sessionStorage.removeItem('mySymbol');
          sessionStorage.removeItem('serverId');
          if(socket && socket.connected) {
               socket.disconnect();
               console.log("Reset: Disconnected socket from previous online game (if any).");
          }
           console.log("Reset: Online game state variables and session storage cleared."); // Log state reset


          // --- Update UI to show selection screen ---
          if(gameControlsElement) gameControlsElement.style.display = 'flex'; // Show mode selection buttons
          console.log("Reset: Showing game controls."); // Log UI change

          // Show bot difficulty selection as it's part of the local mode selection
          if(botDifficultySelection) botDifficultySelection.style.display = 'flex';
          console.log("Reset: Showing bot difficulty selection."); // Log UI change

          if(gameEndButtonsContainer) gameEndButtonsContainer.style.display = 'none'; // Hide end buttons
          console.log("Reset: Hiding game end buttons container."); // Log UI change


           // Crucially: HIDE THE BOARD when showing the controls
           if(boardElement) {
               boardElement.style.display = 'none';
               console.log("Reset: Hiding board element."); // Log UI change
           } else {
                console.error("Board element not found!");
           }

           // Render an empty board state even if hidden, to clear any symbols/highlights
           renderBoard(local_cells); // Render empty cells
           // Note: renderBoard calls enableLocalBoardClicking which will correctly disable clicks as local_gameMode is ''

          // Update status message using the helper function
          updateLocalGameStatus(); // This will set the "Select a mode..." message
          console.log("Reset: Called updateLocalGameStatus."); // Log function call


          // Remove body class indicating game is active
          document.body.classList.remove('game-started');
          console.log("Reset: Removed 'game-started' class from body."); // Log class change

           // Reset dropdown value visually (optional)
           if (botDifficultyDropdown) botDifficultyDropdown.value = 'easy'; // Or the default you prefer
     }


    // --- Utility Functions ---

    // Gets indices of empty cells from a given board state array
    function getAvailableCells(boardState) {
        const emptyIndices = [];
         // Ensure boardState is an array before iterating
         if (!Array.isArray(boardState)) {
             console.error("getAvailableCells called with invalid boardState:", boardState);
             return [];
         }
         for(let i = 0; i < boardState.length; i++) {
             if (boardState[i] === null) {
                 emptyIndices.push(i);
             }
         }
         return emptyIndices;
    }

    // Checks for a winning line of WIN_LENGTH for a given player on a board layout
    function checkForWinner(playerSymbol, boardLayout) {
        const N_check = N;
        const W_check = WIN_LENGTH;

        if (!boardLayout || !Array.isArray(boardLayout) || boardLayout.length !== N_check * N_check) {
             // console.error("checkForWinner called with invalid boardLayout:", boardLayout); // Suppress excessive logging during minimax simulation
             return null; // Cannot check winner on invalid board
         }

        const directions = [
            { dr: 0, dc: 1 }, // Horizontal
            { dr: 1, dc: 0 }, // Vertical
            { dr: 1, dc: 1 }, // Diagonal /
            { dr: 1, dc: -1 } // Diagonal \
        ];

        // Iterate through all possible starting cells for a WIN_LENGTH line
        // Note: We only need to check cells from which a WIN_LENGTH line *could* start in each direction
        // For horizontal: iterate rows 0 to N-1, cols 0 to N-W_check
        // For vertical: iterate rows 0 to N-W_check, cols 0 to N-1
        // For diagonal /: iterate rows 0 to N-W_check, cols 0 to N-W_check
        // For diagonal \: iterate rows 0 to N-W_check, cols W_check-1 to N-1

        for (let r = 0; r < N_check; r++) {
            for (let c = 0; c < N_check; c++) {

                 // Check for potential winning lines starting from (r, c) in each direction
                 for (const direction of directions) {
                      let count = 0;
                      const combination = [];
                      let possible = true; // Assume it's a possible line for this player until proven otherwise

                      // Check WIN_LENGTH cells in this direction
                      for (let k = 0; k < W_check; k++) {
                          const currRow = r + k * direction.dr;
                          const currCol = c + k * direction.dc;
                          const currIndex = currRow * N_check + currCol;

                            // Check bounds: make sure the current cell is within the grid
                           if (currRow >= 0 && currRow < N_check && currCol >= 0 && currCol < N_check) {
                                // Check if the cell contains the correct player's symbol
                                if (boardLayout[currIndex] === playerSymbol) {
                                    count++;
                                    combination.push(currIndex);
                                } else {
                                    // Found a cell that doesn't match, this is not a winning line starting here
                                    possible = false;
                                    break; // Move to the next direction or starting cell
                                }
                            } else {
                                // Went out of bounds, not a winning line starting here
                                possible = false;
                                break; // Move to the next direction or starting cell
                            }
                      }

                      // If we counted WIN_LENGTH symbols in a row and stayed in bounds
                      if (possible && count === W_check) {
                          // console.log(`Winner found: ${playerSymbol} at r=${r}, c=${c} in direction dr=${direction.dr}, dc=${direction.dc}`); // Suppress excessive logging
                          // Return the player and the winning cell indices
                          return { player: playerSymbol, combination: combination };
                      }
                 }
            }
        }

        return null; // No winner found after checking all cells and directions
     }

    // Highlights the cells in the winning combination
    function highlightWinningCells(combination) {
        console.log("Highlighting winning combination:", combination);
        if (!combination || !Array.isArray(combination) || !boardElement) {
             console.warn("HighlightWinningCells called with invalid combination or boardElement.");
             return;
         }

         // Get current cell elements rendered on the board
         const currentCells = boardElement.children;

        combination.forEach(index => {
            // Ensure the index is valid and the cell element exists in the *current* DOM
            if (index >= 0 && index < currentCells.length) {
                 const cellElement = currentCells[index];
                 if (cellElement) {
                     cellElement.classList.add('winning');
                     // console.log("Added 'winning' class to cell index", index); // Suppress logging
                 } else {
                     console.warn("Cell element not found for index", index, "during highlighting.");
                 }
            } else {
                 console.warn("Invalid index in winning combination:", index);
            }
        });
    }

    // Renders the entire board based on the provided state array
    function renderBoard(boardToRender) {
        // console.log("renderBoard called with state:", boardToRender); // Avoid spamming console
        if (!boardElement) {
             console.error("Game board element with ID 'board' not found for rendering!");
             return;
         }

        // Clear existing cells from the DOM
        boardElement.innerHTML = '';
         // Set grid dimensions based on N (redundant if in CSS, but safe)
         boardElement.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
         boardElement.style.gridTemplateRows = `repeat(${N}, 1fr)`;

        // Validate input board state
        if (!boardToRender || !Array.isArray(boardToRender) || boardToRender.length !== N * N) {
             console.error("renderBoard called with invalid or missing board state. Rendering empty grid.");
             // Render an empty grid structure even if state is bad
             boardToRender = Array(N * N).fill(null);
         }

        // Create and append cell elements
        boardToRender.forEach((cellValue, index) => {
            const cellElement = document.createElement('div');
            cellElement.className = 'cell'; // Start with the base cell class
            cellElement.dataset.index = index; // Add data attribute for easy lookup

            // Add symbol and state classes if cell is taken
            if (cellValue) {
                cellElement.textContent = cellValue;
                // Add the player symbol class (x or o) which controls colors
                cellElement.classList.add(cellValue.toLowerCase());
                // Add the taken class (disables clicks)
                cellElement.classList.add('taken');
                // No need to remove 'clickable' here, it's handled by enable...Clicking functions
                // No need to set pointer-events here, handled by enable...Clicking functions
            }

            // Add click listener - Use the appropriate handler based on game mode
            // Attach a single handler that checks the current game state (mm_roomId or local_gameMode)
            cellElement.addEventListener('click', (event) => {
                 if (mm_roomId) { // Check if online game is active
                     handleOnlineCellClick(event); // Pass the event object
                 } else if (local_gameMode) { // Check if a local game mode is active
                      handleLocalCellClick(event); // Pass the event object
                 }
                 // If no mode is set (selection screen), clicks are effectively ignored by the handlers' internal checks
            });


            boardElement.appendChild(cellElement);

             // Add winning class if part of the global winningCombination (set after game end)
             if (winningCombination && Array.isArray(winningCombination) && winningCombination.includes(index)) {
                 cellElement.classList.add('winning');
             }
             // Note: No need to remove 'winning' class here, as innerHTML clears existing classes before adding.
        });

        // After rendering, update clickability based on the current game mode/state
        if (mm_roomId) {
             enableBoardClicking(); // Online click logic
        } else { // Local game or mode selection state
             enableLocalBoardClicking(); // Local click logic (enabled for human turns unless game over or selection state)
        }
         console.log("renderBoard completed. Clickability updated."); // Log completion
    }


  </script>
</body>
</html>
```

